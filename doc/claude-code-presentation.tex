\documentclass[aspectratio=169]{beamer}
\usetheme{metropolis}

% Packages
\usepackage{booktabs}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{graphicx}

% Unicode symbols for icons (no fontawesome5 needed)
\newcommand{\faIcon}[1]{%
  \ifnum\pdfstrcmp{#1}{terminal}=0 $\blacktriangleright$\fi%
  \ifnum\pdfstrcmp{#1}{code}=0 $\langle\!\rangle$\fi%
  \ifnum\pdfstrcmp{#1}{robot}=0 $\clubsuit$\fi%
  \ifnum\pdfstrcmp{#1}{search}=0 $\bigcirc$\fi%
  \ifnum\pdfstrcmp{#1}{edit}=0 $\triangleright$\fi%
  \ifnum\pdfstrcmp{#1}{check}=0 $\checkmark$\fi%
  \ifnum\pdfstrcmp{#1}{times}=0 $\times$\fi%
  \ifnum\pdfstrcmp{#1}{linux}=0 $\bigstar$\fi%
  \ifnum\pdfstrcmp{#1}{apple}=0 $\bigcirc$\fi%
  \ifnum\pdfstrcmp{#1}{windows}=0 $\square$\fi%
  \ifnum\pdfstrcmp{#1}{github}=0 $\bullet$\fi%
  \ifnum\pdfstrcmp{#1}{book}=0 $\equiv$\fi%
  \ifnum\pdfstrcmp{#1}{folder}=0 $\diamondsuit$\fi%
}

% Code highlighting
\lstset{
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
  stringstyle=\color{red},
  showstringspaces=false,
  breaklines=true,
  frame=single,
  numbers=left,
  numberstyle=\tiny\color{gray}
}

% Title page
\title{Supercharging C++ Development with Claude Code}
\subtitle{How AI-Powered Workflow Automation Transformed My Development Process}
\author{Martin Kjeldsen}
\date{\today}
\institute{}

\begin{document}

\maketitle

% Table of Contents
\begin{frame}{Outline}
  \tableofcontents
\end{frame}

% ============================================================================
\section{What is Claude Code?}
% ============================================================================

\begin{frame}{Claude Code: AI-Powered Development Assistant}
  \begin{columns}
    \column{0.5\textwidth}
    \textbf{Claude Code (CC)} is Anthropic's official CLI tool

    \vspace{1em}
    \textbf{Key Features:}
    \begin{itemize}
      \item \faIcon{terminal} Interactive terminal interface
      \item \faIcon{code} Full codebase awareness
      \item \faIcon{robot} Autonomous task execution
      \item \faIcon{search} Intelligent code search
      \item \faIcon{edit} Multi-file editing
    \end{itemize}

    \column{0.5\textwidth}
    \begin{alertblock}{Not Just a Chatbot}
      Claude Code can:
      \begin{itemize}
        \item Read your entire codebase
        \item Execute shell commands
        \item Edit multiple files
        \item Run git operations
        \item Debug and test code
      \end{itemize}
    \end{alertblock}
  \end{columns}
\end{frame}

\begin{frame}{Why Claude Code?}
  \begin{columns}
    \column{0.5\textwidth}
    \textbf{Traditional Development:}
    \begin{itemize}
      \item Manual file navigation
      \item Repetitive boilerplate
      \item Context switching
      \item Documentation hunting
      \item Tool configuration hell
    \end{itemize}

    \column{0.5\textwidth}
    \textbf{With Claude Code:}
    \begin{itemize}
      \item[\faIcon{check}] Natural language tasks
      \item[\faIcon{check}] Automated scaffolding
      \item[\faIcon{check}] Maintains context
      \item[\faIcon{check}] Built-in knowledge
      \item[\faIcon{check}] One-command setup
    \end{itemize}
  \end{columns}

  \vspace{2em}
  \centering
  \Large{\textbf{From hours to minutes.}}
\end{frame}

% ============================================================================
\section{The Workflow Revolution}
% ============================================================================

\begin{frame}{Before Claude Code: The Old Workflow}
  \textbf{Starting a new C++ project meant:}

  \begin{enumerate}
    \item Create directory structure manually
    \item Copy-paste CMakeLists.txt from old project
    \item Setup .gitignore, .clang-format, .clang-tidy
    \item Configure LSP (clangd) settings
    \item Setup debugger configurations
    \item Initialize git repository
    \item Write README boilerplate
  \end{enumerate}

  \vspace{1em}
  \begin{exampleblock}{Time Investment}
    \textbf{30-60 minutes} of tedious setup before writing any actual code
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{After Claude Code: One Command}
  \textbf{Now starting a new project:}

  \begin{lstlisting}[language=bash]
$ ~/dotfiles/scripts/bootstrap-cpp-project.sh my-renderer
[INFO] Creating C++ project: my-renderer
[INFO] Location: /home/user/dev/my-renderer
[INFO] Created directory structure
[INFO]   OK CLAUDE.md
[INFO]   OK .clangd
[INFO]   OK CMakeLists.txt
[INFO]   OK .nvim.lua (debug configs)
[INFO]   OK src/main.cpp
[INFO]   OK Git repository initialized

OK Project created successfully!
  \end{lstlisting}

  \begin{exampleblock}{Time Investment}
    \textbf{5 seconds} and you're ready to code
  \end{exampleblock}
\end{frame}

\begin{frame}{CLAUDE.md: The Secret Weapon}
  \textbf{Every project gets a CLAUDE.md file:}

  \vspace{1em}
  \begin{columns}
    \column{0.5\textwidth}
    \textbf{What it contains:}
    \begin{itemize}
      \item Project overview
      \item Architecture notes
      \item Build commands
      \item Testing instructions
      \item Common tasks
      \item Recent changes
    \end{itemize}

    \column{0.5\textwidth}
    \textbf{Why it matters:}
    \begin{itemize}
      \item Claude reads it automatically
      \item Maintains project context
      \item Onboards new developers
      \item Living documentation
      \item Prevents knowledge loss
    \end{itemize}
  \end{columns}

  \vspace{2em}
  \begin{alertblock}{Key Insight}
    CLAUDE.md turns every conversation into a context-aware collaboration
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]{Example: CLAUDE.md in Action}
  \textbf{Without CLAUDE.md:}
  \begin{lstlisting}[language=bash]
You: "Add a new renderer class"
Claude: "Which file should I add it to? What's the
         architecture? What rendering API are you using?"
  \end{lstlisting}

  \vspace{1em}
  \textbf{With CLAUDE.md:}
  \begin{lstlisting}[language=bash]
You: "Add a new renderer class"
Claude: *reads CLAUDE.md* "I see you're using Skia for
        rendering. I'll add it to src/renderer.cpp
        following your existing factory pattern."
  \end{lstlisting}

  \vspace{1em}
  \centering
  \textbf{Zero back-and-forth. Pure productivity.}
\end{frame}

\begin{frame}{It's Not Just C++}
  \textbf{The same workflow works for TypeScript!}

  \vspace{1em}
  \begin{columns}
    \column{0.5\textwidth}
    \textbf{C++ Bootstrap:}
    \begin{itemize}
      \item clang-format
      \item clang-tidy
      \item CMakeLists.txt
      \item .clangd LSP config
      \item codelldb debugger
      \item Git hooks
    \end{itemize}

    \column{0.5\textwidth}
    \textbf{TypeScript Bootstrap:}
    \begin{itemize}
      \item Prettier
      \item ESLint
      \item tsconfig.json
      \item ts\_ls LSP config
      \item Node.js debugger
      \item Git hooks
    \end{itemize}
  \end{columns}

  \vspace{2em}
  \begin{alertblock}{Multi-Language Support}
    Same philosophy, different tools. One workflow for all your projects.
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]{TypeScript Workflow in Action}
  \textbf{Creating a React + TypeScript app:}

  \begin{lstlisting}[language=bash]
$ ~/dotfiles/scripts/bootstrap-ts-project.sh \
    my-app --framework=react

[INFO] Creating TypeScript project: my-app
[INFO] Framework: react
[INFO]   OK tsconfig.json
[INFO]   OK .eslintrc.json
[INFO]   OK .prettierrc
[INFO]   OK package.json
[INFO]   OK CLAUDE.md
[INFO]   OK Git hooks installed

$ cd my-app && npm install && npm run dev
  VITE ready in 191 ms
  Local: http://localhost:5173/
  \end{lstlisting}

  \vspace{0.5em}
  \centering
  \textbf{From zero to hot-reload dev server in under 60 seconds.}
\end{frame}

\begin{frame}{Real Example: We Just Did This}
  \textbf{10 minutes ago, we built a complete TypeScript workflow from scratch:}

  \vspace{1em}
  \begin{columns}
    \column{0.5\textwidth}
    \textbf{What we created:}
    \begin{itemize}
      \item TypeScript stow package
      \item Bootstrap script (4 frameworks)
      \item Neovim LSP + DAP config
      \item Git hooks (pre-commit/push)
      \item Demo React app
      \item Full documentation
    \end{itemize}

    \column{0.5\textwidth}
    \textbf{Time breakdown:}
    \begin{itemize}
      \item tsconfig/ESLint/Prettier/Vitest: 2 min
      \item Neovim TypeScript support: 1 min
      \item Bootstrap script (4 frameworks): 3 min
      \item Git hooks (4 quality gates): 2 min
      \item Testing demo project: 2 min
    \end{itemize}
  \end{columns}

  \vspace{2em}
  \begin{alertblock}{Total: 10 Minutes}
    From "I don't have TypeScript support" to "Working React app with full quality gates"
  \end{alertblock}
\end{frame}

\begin{frame}{TypeScript Framework Support}
  \textbf{One script, four frameworks:}

  \vspace{1em}
  \begin{description}
    \item[--framework=node] Simple Node.js CLI apps with tsx
    \item[--framework=express] REST APIs with Express + TypeScript
    \item[--framework=react] React apps with Vite + HMR
    \item[--framework=next] Next.js 14+ with App Router
  \end{description}

  \vspace{2em}
  \textbf{All include:}
  \begin{itemize}
    \item Strict TypeScript config (no implicit any)
    \item ESLint + Prettier + Vitest pre-configured
    \item Git hooks (4 quality gates: format, types, lint, tests)
    \item Neovim LSP + DAP debugging ready
    \item CLAUDE.md with framework-specific guidance
    \item Sample tests auto-generated for each framework
  \end{itemize}
\end{frame}

% ============================================================================
\section{Automated Code Quality}
% ============================================================================

\begin{frame}{Git Hooks: Quality Gates on Autopilot}
  \textbf{Automatic enforcement for all languages:}

  \vspace{1em}
  \begin{columns}
    \column{0.5\textwidth}
    \textbf{C++ Projects:}
    \begin{itemize}
      \item Pre-commit: clang-format
      \item Pre-push: clang-tidy
      \item Fix: \texttt{git cf}
      \item ASCII art on violations
    \end{itemize}

    \vspace{1em}
    \textbf{TypeScript Projects:}
    \begin{itemize}
      \item Pre-commit: Prettier
      \item Pre-push: tsc + ESLint + Vitest
      \item Fix: \texttt{npm run format}
      \item Type errors \& test failures blocked
    \end{itemize}

    \column{0.5\textwidth}
    \textbf{How It Works:}
    \begin{itemize}
      \item Bootstrap script installs hooks
      \item Runs on every commit/push
      \item Fast (staged files only)
      \item Catches issues before review
      \item Bypass: \texttt{--no-verify}
    \end{itemize}

    \vspace{1em}
    \begin{alertblock}{Philosophy}
      Make the right thing automatic
    \end{alertblock}
  \end{columns}
\end{frame}

\begin{frame}[fragile]{Pre-commit Hook in Action}
  \textbf{Formatting violation detected:}

  \begin{lstlisting}[basicstyle=\ttfamily\tiny]
Checking C++ code formatting...

src/renderer.cpp needs formatting:

  *** CODE FORMATTING VIOLATIONS DETECTED! ***

How to fix:
  git cf                    # Format staged files
  git commit                # Try again

To bypass (not recommended):
  git commit --no-verify
  \end{lstlisting}

  \vspace{0.5em}
  \centering
  \textbf{No more "I'll fix formatting later" — it's enforced automatically.}
\end{frame}

% ============================================================================
\section{Cross-Platform Dotfiles}
% ============================================================================

\begin{frame}{One Dotfiles Repo, Four Platforms}
  \textbf{Unified configuration across:}

  \vspace{1em}
  \begin{description}
    \item[\faIcon{linux} Arch Linux] Full Hyprland desktop + all dev tools
    \item[\faIcon{linux} WSL] CLI tools only (no GUI)
    \item[\faIcon{apple} macOS] Homebrew + Alacritty terminal
    \item[\faIcon{windows} Windows] Scoop + Windows Terminal
  \end{description}

  \vspace{2em}
  \begin{columns}
    \column{0.5\textwidth}
    \textbf{Shared configs:}
    \begin{itemize}
      \item Git (hooks, aliases)
      \item Neovim (full IDE)
      \item Clang tools
      \item Starship prompt
    \end{itemize}

    \column{0.5\textwidth}
    \textbf{Platform-specific:}
    \begin{itemize}
      \item Package managers
      \item Bash configs
      \item Terminal emulators
      \item Desktop environments
    \end{itemize}
  \end{columns}
\end{frame}

\begin{frame}[fragile]{Platform Installation}
  \textbf{Each platform has a one-command install:}

  \begin{lstlisting}[language=bash]
# Arch Linux
./install_arch.sh

# WSL (Ubuntu/Debian)
./install_wsl.sh

# macOS
./install_darwin.sh
  \end{lstlisting}

  \begin{lstlisting}
# Windows (PowerShell)
.\install_windows.ps1
  \end{lstlisting}

  \vspace{1em}
  \begin{alertblock}{Built with Claude Code}
    All four install scripts were created collaboratively with CC in one session
  \end{alertblock}
\end{frame}

% ============================================================================
\section{Unreal Engine Development}
% ============================================================================

\begin{frame}{Neovim + Unreal Engine = Possible}
  \textbf{Configured for UE C++ coding standards:}

  \vspace{1em}
  \begin{columns}
    \column{0.5\textwidth}
    \textbf{What works:}
    \begin{itemize}
      \item[\faIcon{check}] LSP (clangd)
      \item[\faIcon{check}] Debugging (DAP)
      \item[\faIcon{check}] Formatting (Allman braces)
      \item[\faIcon{check}] Static analysis
      \item[\faIcon{check}] Git hooks
    \end{itemize}

    \column{0.5\textwidth}
    \textbf{UE Standards:}
    \begin{itemize}
      \item PascalCase naming
      \item Type prefixes (U/A/F/E/T)
      \item Boolean prefix (b)
      \item Tab indentation
      \item Always-braces policy
    \end{itemize}
  \end{columns}

  \vspace{2em}
  \begin{exampleblock}{Hybrid Workflow}
    Neovim for C++ code, Unreal Editor for Blueprints/Assets (7/10 feasibility)
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{UE Clang-Tidy Configuration}
  \textbf{Enforces Unreal Engine coding standards:}

  \begin{lstlisting}[basicstyle=\ttfamily\tiny]
# .clang-tidy configured for UE

CheckOptions:
  # PascalCase for everything (not snake_case)
  - key: readability-identifier-naming.FunctionCase
    value: CamelCase
  - key: readability-identifier-naming.VariableCase
    value: CamelCase

  # No private member suffix (UE doesn't use trailing _)
  - key: readability-identifier-naming.PrivateMemberSuffix
    value: ''

  # Always-braces policy
  - key: readability-braces-around-statements.ShortStatementLines
    value: 0
  \end{lstlisting}

  \vspace{0.5em}
  \centering
  \textbf{Pre-push hook catches naming violations before code review.}
\end{frame}

% ============================================================================
\section{Real-World Impact}
% ============================================================================

\begin{frame}{Productivity Gains: By The Numbers}
  \begin{table}
    \centering
    \begin{tabular}{lcc}
      \toprule
      \textbf{Task} & \textbf{Before CC} & \textbf{With CC} \\
      \midrule
      New C++ project setup & 30-60 min & 5 sec \\
      New TS/React project & 20-40 min & 5 sec \\
      Configure LSP/DAP & 20-30 min & 0 min (automatic) \\
      Setup git hooks & 15-20 min & 0 min (automatic) \\
      TSConfig + ESLint + Prettier + Vitest & 15-25 min & 0 min (automatic) \\
      Cross-platform config & Hours/days & 1 session \\
      Format code & Manual & Automatic (pre-commit) \\
      Type/lint checking & Manual & Automatic (pre-push) \\
      Find project docs & N/A & Instant (CLAUDE.md) \\
      \bottomrule
    \end{tabular}
  \end{table}

  \vspace{1em}
  \begin{alertblock}{Time Saved}
    \textbf{2+ hours per project} in setup and configuration alone
  \end{alertblock}
\end{frame}

\begin{frame}{GitHub Activity: The Proof}
  \begin{center}
    \includegraphics[width=0.85\textwidth]{github-activity.png}
  \end{center}

  \vspace{1em}
  \begin{alertblock}{754 Contributions in the Last Year}
    The activity surge shows consistent productivity with Claude Code — more commits, better workflow, cleaner code.
  \end{alertblock}
\end{frame}

\begin{frame}{Workflow Improvements}
  \textbf{What changed with Claude Code:}

  \vspace{1em}
  \begin{enumerate}
    \item \textbf{Context Switching} — Eliminated via CLAUDE.md
    \item \textbf{Boilerplate Code} — Automated via templates
    \item \textbf{Configuration Hell} — One-command install scripts
    \item \textbf{Code Quality} — Enforced via git hooks
    \item \textbf{Documentation Rot} — Prevented via living CLAUDE.md
    \item \textbf{Platform Fragmentation} — Unified dotfiles
  \end{enumerate}

  \vspace{2em}
  \centering
  \Large{\textbf{Focus on solving problems, not fighting tools.}}
\end{frame}

% ============================================================================
\section{Best Practices}
% ============================================================================

\begin{frame}{Best Practices for Using Claude Code}
  \begin{enumerate}
    \item \textbf{Maintain CLAUDE.md} — Update it as the project evolves
    \item \textbf{Generate compile\_commands.json} — Required for LSP
    \item \textbf{Use project-local configs} — .clangd, .nvim.lua, etc.
    \item \textbf{Trust the hooks} — Don't bypass pre-commit/pre-push
    \item \textbf{Template everything} — Bootstrap scripts for consistency
    \item \textbf{Document conventions} — Put them in CLAUDE.md
    \item \textbf{Version your dotfiles} — Git repo with install scripts
  \end{enumerate}

  \vspace{1em}
  \begin{alertblock}{Golden Rule}
    Invest time in automation once, reap benefits forever
  \end{alertblock}
\end{frame}

\begin{frame}{What NOT to Use Claude Code For}
  \textbf{CC is powerful, but not magic:}

  \vspace{1em}
  \begin{itemize}
    \item \faIcon{times} \textbf{Complex debugging} — Use a proper debugger (gdb/lldb)
    \item \faIcon{times} \textbf{Graphical design} — Use specialized tools (Unreal Editor, Blender, etc.)
    \item \faIcon{times} \textbf{Performance profiling} — Use profilers (perf, Valgrind, etc.)
    \item \faIcon{times} \textbf{Real-time interaction} — CC has latency, not instant
    \item \faIcon{times} \textbf{Binary/compiled analysis} — CC works with source code
  \end{itemize}

  \vspace{2em}
  \begin{exampleblock}{Use Case}
    Claude Code excels at \textbf{automation, scaffolding, and refactoring} — not runtime operations
  \end{exampleblock}
\end{frame}

% ============================================================================
\section{Live Demo}
% ============================================================================

\begin{frame}{Live Demo: The Four Quality Gates}
  \textbf{Let's write some bad code and watch the gates catch it!}

  \vspace{1em}
  \begin{columns}
    \column{0.5\textwidth}
    \textbf{What we'll break:}
    \begin{itemize}
      \item Double quotes (Prettier)
      \item Missing spaces (Prettier)
      \item Implicit \texttt{any} types (TypeScript)
      \item Missing return types (ESLint)
      \item Failing tests (Vitest)
    \end{itemize}

    \column{0.5\textwidth}
    \textbf{What will catch it:}
    \begin{itemize}
      \item Gate 1: Prettier
      \item Gate 2: TypeScript
      \item Gate 3: ESLint
      \item Gate 4: Vitest
    \end{itemize}
  \end{columns}

  \vspace{2em}
  \begin{alertblock}{The Goal}
    Show that you literally cannot push broken code
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]{Gate 1: Prettier Catches Formatting}
  \textbf{Writing code with bad formatting:}

  \begin{lstlisting}[basicstyle=\ttfamily\tiny]
// Bad formatting - inconsistent quotes and spacing
import React, { useState } from "react";

const Counter = () => {
  const [count,setCount]=useState(0);  // No spaces!
  ...
};
  \end{lstlisting}

  \vspace{1em}
  \textbf{Run formatter:}
  \begin{lstlisting}[language=bash,basicstyle=\ttfamily\tiny]
$ npm run format
src/Counter.tsx 17ms
  \end{lstlisting}

  \vspace{0.5em}
  \textbf{Result:}
  \begin{lstlisting}[basicstyle=\ttfamily\tiny]
import React, { useState } from 'react';  // Single quotes!

const Counter = () => {
  const [count, setCount] = useState(0);  // Proper spacing!
  ...
};
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Gate 2: TypeScript Catches Type Errors}
  \textbf{Type checker finds implicit any:}

  \begin{lstlisting}[basicstyle=\ttfamily\tiny]
$ npm run type-check

src/Counter.tsx(11,24): error TS7006:
  Parameter 'e' implicitly has an 'any' type.

const handleClick = (e) => {  // <-- No type!
  setCount(count + 1);
};
  \end{lstlisting}

  \vspace{1em}
  \textbf{Fix by adding explicit types:}
  \begin{lstlisting}[basicstyle=\ttfamily\tiny]
const handleClick = (): void => {  // <-- Explicit return type
  setCount(count + 1);
};
  \end{lstlisting}

  \vspace{0.5em}
  \centering
  \textbf{Strict mode prevents implicit any — no shortcuts allowed!}
\end{frame}

\begin{frame}[fragile]{Gate 3: ESLint Enforces Best Practices}
  \textbf{ESLint catches missing return types:}

  \begin{lstlisting}[basicstyle=\ttfamily\tiny]
$ npm run lint

src/Counter.tsx
  8:20  warning  Missing return type on function
        @typescript-eslint/explicit-function-return-type

const Counter = () => {  // <-- No return type!
  ...
};
  \end{lstlisting}

  \vspace{1em}
  \textbf{Fix by adding JSX.Element return type:}
  \begin{lstlisting}[basicstyle=\ttfamily\tiny]
const Counter = (): JSX.Element => {  // <-- Explicit!
  ...
};
  \end{lstlisting}

  \vspace{0.5em}
  \centering
  \textbf{Three gates down, one more to go!}
\end{frame}

\begin{frame}[fragile]{Gate 4: Vitest Catches Logic Bugs}
  \textbf{Tests verify runtime behavior:}

  \begin{lstlisting}[basicstyle=\ttfamily\tiny]
$ npm run test:run

src/Counter.test.tsx
  OK renders with initial count of 0
  OK displays the increment button
  OK increments count when button is clicked
  OK increments multiple times correctly

Test Files  1 passed (1)
     Tests  4 passed (4)
  Duration  1.25s
  \end{lstlisting}

  \vspace{1em}
  \textbf{What Vitest catches that others can't:}
  \begin{itemize}
    \item Incorrect logic (button doesn't increment)
    \item Wrong initial values (starts at 10 instead of 0)
    \item Runtime errors (undefined function calls)
    \item Component behavior bugs
  \end{itemize}

  \vspace{0.5em}
  \centering
  \textbf{All four gates passed — code is ready to push!}
\end{frame}

\begin{frame}{Live Demo: Bootstrap a Project}
  \textbf{Let's create a new C++ project from scratch:}

  \vspace{1em}
  \begin{enumerate}
    \item Run bootstrap script
    \item Show generated files (CLAUDE.md, CMakeLists.txt, .nvim.lua)
    \item Build the project
    \item Open in Neovim
    \item Show LSP features (go-to-definition, autocomplete)
    \item Show debug configurations (F5 to debug)
    \item Make a change and commit (pre-commit hook triggers)
  \end{enumerate}

  \vspace{2em}
  \centering
  \textbf{From zero to fully-configured IDE in under 60 seconds.}
\end{frame}

\begin{frame}{Live Demo: Claude Code in Action}
  \textbf{Typical Claude Code session:}

  \vspace{1em}
  \begin{enumerate}
    \item Ask CC to add a new feature
    \item CC reads CLAUDE.md for context
    \item CC explores codebase (grep, read files)
    \item CC writes code across multiple files
    \item CC runs tests to verify
    \item CC commits with descriptive message
  \end{enumerate}

  \vspace{2em}
  \begin{alertblock}{Key Observation}
    You describe \textit{what} you want, Claude Code figures out \textit{how}
  \end{alertblock}
\end{frame}

% ============================================================================
\section{Conclusion}
% ============================================================================

\begin{frame}{Key Takeaways}
  \begin{enumerate}
    \item \textbf{CLAUDE.md is essential} — Project context changes everything
    \item \textbf{Automate setup} — Bootstrap scripts save hours
    \item \textbf{Git hooks enforce quality} — Pre-commit + pre-push = clean code
    \item \textbf{Cross-platform dotfiles} — Write once, run everywhere
    \item \textbf{Invest in tooling} — Good tools compound over time
  \end{enumerate}

  \vspace{2em}
  \centering
  \Large{\textbf{Claude Code isn't just a tool — it's a workflow multiplier.}}
\end{frame}

\begin{frame}{Resources}
  \textbf{Learn More:}

  \vspace{1em}
  \begin{itemize}
    \item \faIcon{github} GitHub: \url{https://github.com/anthropics/claude-code}
    \item \faIcon{book} Documentation: \url{https://claude.com/claude-code}
    \item \faIcon{folder} My Dotfiles: \url{https://github.com/zrrbite/dotfiles}
  \end{itemize}

  \vspace{2em}
  \begin{center}
    \Large{\textbf{Questions?}}
  \end{center}

  \vspace{2em}
  \footnotesize{
    This presentation was created \textit{with} Claude Code, naturally.
  }
\end{frame}

\end{document}
